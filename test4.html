<!DOCTYPE html>
<html>

<head>
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <style type="text/css">
        .div1 {
            height: 230px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .div2 {
            padding-top: 200px;
            height: 800px;
            background-color: #ddd;
            overflow: hidden;
        }

        .myDiv {
            margin-top: 50px;
            width: 50px;
            height: 50px;
            background-color: pink;
        }
    </style>
    <script>
        delete window.IntersectionObserver;
    </script>
    <script src="node_modules/intersection-observer/intersection-observer.js"></script>
</head>

<body>
    <div id=a class="div1">
        <div class="myDiv">1</div>
        <div class="myDiv">2</div>
        <div class="myDiv">3</div>
        <div class="myDiv">4</div>
        <div class="myDiv">5</div>
        <div class="myDiv">6</div>
        <div class="myDiv">7</div>
        <div class="myDiv">8</div>
        <div class="myDiv">9</div>
        <div class="myDiv">10</div>
        <div class="myDiv">11</div>
        <div class="myDiv">12</div>
    </div>
    <script>
        // 节流函数
        var throttle = function () {
            var time = 0;
            return function (fn) {
                return function () {
                    var now = new Date().getTime();
                    if (now - time > 100) {
                        time = now;
                        fn.apply(this, arguments)
                    }
                }
            };
        }();

        /**
         * 两种类型，曝光(exposure,默认), 停留(stay)
         * 
         */
        var Scroll = function (opt) {

            var me = this;
            console.log('constructor');
            var events = this.events = [];
            this.selector = opt.selector;

            var type = Object.prototype.toString.call(opt.type) == '[object Array]' ? opt.type : [opt.type];


            var domArr = [];    // 曝光事件使用的数组
            var domArrStay = [];    // 停留事件使用的数组

            var doms = document.querySelectorAll(this.selector);
            var visibleDoms = this.visibleDoms = [];   // 处于可见区域的dom

            var container = opt.container || doms[0] && doms[0].parentNode || window;

            // 初始化时设置的监听事件
            if (opt.listeners) {
                for (var k in opt.listeners) {
                    this.on(k, opt.listeners[k]);
                }
            }

            var actions = {
                stay: function (item) {
                    if (item.isIntersecting) {
                        item.target.accessTime = item.time; // 展示的时候把时间记录在dom上
                    } else {
                        var stayTime = item.time - item.target.accessTime;  // 消失的时候计算
                        if (stayTime > 3000) {
                            //console.log('stayTime', stayTime, item.target)
                            domArrStay.push(item.target);
                        }
                    }
                },
                exposure: function (item) {
                    if (item.isIntersecting) {
                        if (item.intersectionRatio > 0.6666666) {
                            console.log('进入2/3', item.target, item.intersectionRatio)
                            if (!domArr.some(function (it) {
                                return it === item.target;
                            })) {
                                domArr.push(item.target)
                            }
                        }
                    }
                }
            }

            var isInit;
            var observer = this.observer = new IntersectionObserver(function (entries) {
                entries.forEach(function (item) {
                    opt.type.forEach(function (t) {
                        actions[t] && actions[t].call(this, item);
                    })

                    /*
                    if (opt.type == 'stay') {   // 停留，停留超过一定时间才视为有效
                        if (item.isIntersecting) {
                            item.target.accessTime = item.time; // 展示的时候把时间记录在dom上
                        } else {
                            var stayTime = item.time - item.target.accessTime;  // 消失的时候计算
                            if (stayTime > 3000) {
                                //console.log('stayTime', stayTime, item.target)
                                domArrStay.push(item.target);
                            }
                        }
                    } else {    // 曝光，只要在可视区域出现即视为曝光
                        if (item.isIntersecting) {
                            if (item.intersectionRatio > 0.6666666) {
                                console.log('进入2/3', item.target, item.intersectionRatio)
                                if (!domArr.some(function (it) {
                                    return it === item.target;
                                })) {
                                    domArr.push(item.target)
                                }
                            }
                        }
                    }
                    */

                    if (item.intersectionRatio > 0.6666666) {
                        //console.log('展示', item.target)
                        visibleDoms.push(item.target);
                    } else {
                        //console.log('消失', item.target)
                        for (var i = 0; i < visibleDoms.length; i++) {
                            if (visibleDoms[i] === item.target) {
                                visibleDoms.splice(i, 1);
                            }
                        }
                    }
                });

                clearTimeout(stayTimer);

                // 初始化时触发一次stop
                if (!isInit) {
                    me.fireEvent('stop', domArr);
                    isInit = true;
                }
                // observer.disconnect() // 统计到就不在需要继续观察了
            }, {
                root: container,
                threshold: [0.6666666]  // 触发时机, 2/3可见时触发
            });
            doms.forEach(function (item) {
                observer.observe(item);
            });



            var stayTimer;
            // 停留事件，在停止滚动时setTimeout3秒后尝试发送停留事件，
            // 如果3s内IntersectionObserver状态有改变，则清除此setTimeout
            if (type.indexOf('stay') > -1) {
                this.on('stop', function () {
                    stayTimer = setTimeout(function () {
                        visibleDoms.forEach(function (dom) {
                            if (!domArrStay.some(function (it) {
                                return it === dom;
                            })) {
                                domArrStay.push(dom);
                            }
                        });

                        me.fireEvent('stay', domArrStay);
                        domArrStay = [];
                    }, 3000);
                });
            }


            // scroll事件主要用于兼听停止滚动时动作
            container.addEventListener('scroll', throttle(function () {
                var scrollTop;
                var isScroll;
                var stopTimer;

                // 获取container的scrollTop，ios下只能获取到window的pageYOffset
                function getScrollTop(container) {
                    container = container == window ? document.body : container;
                    return container.scrollTop || window.pageYOffset;
                }

                return function () {
                    if (!isScroll) {
                        isScroll = true;
                        domArr = [];    // 开始滚动时初始化domArr
                    }

                    clearInterval(stopTimer);
                    var oldScrollTop = getScrollTop(container);;
                    stopTimer = setInterval(function () {
                        var scrollTop = getScrollTop(container);
                        if (scrollTop == oldScrollTop) {
                            me.fireEvent('stop', domArr);
                            isScroll = false;
                            clearInterval(stopTimer);
                        }
                        oldScrollTop = scrollTop;
                    }, 300);
                }
            }()));
        }

        Scroll.prototype = {
            constructor: Scroll,
            reload: function () {   // 重新读取dom(用于目标dom有变化的场合)
                var me = this;
                var doms = document.querySelectorAll(this.selector);

                doms.forEach(function (item) {
                    me.observer.unobserve(item);
                    me.observer.observe(item);
                });
            },
            getVisibleDoms: function () {
                return this.visibleDoms;
            },
            // 动态添加的监听事件
            on: function (eventName, eventFn) {
                if (/^[\w-]+$/.test(eventName) && typeof eventFn == 'function') {
                    this.events.push({
                        name: eventName,
                        fn: eventFn
                    });
                }
            },
            fireEvent: function (eventName) {
                var me = this;
                var _arguments = arguments;
                if (eventName == undefined) {
                    return;
                }
                var eventFns = this.events.filter(function (it) {
                    return it.name == eventName;
                });

                eventFns.forEach(function (it) {
                    it.fn && it.fn.apply(me, Array.prototype.splice.call(_arguments, 1));
                });
            }
        }

        var s = new Scroll({
            selector: '#a .myDiv',
            type: ['exposure'],
            listeners: {
                stop: function (a) {
                    console.log("stop", a)
                },
                stay: function (doms) {
                    console.log('发送停留事件', doms.map(function (it) {
                        return it.innerHTML;
                    }));
                }
            }
        });



        // callback 回调函数
        // option 配置对象
        // var io = new IntersectionObserver(callback, option);

        // 开始观察
        // io.observe(document.getElementById('myDiv'));
        // observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。

        // // 停止观察
        // io.unobserve(document.getElementById('myDiv'));

        // // 关闭观察器
        // io.disconnect();


    </script>
</body>

</html>